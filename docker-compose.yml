version: '3.8'
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: product_marketplace
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  backend:
    build: ./backend
    command: python manage.py runserver 0.0.0.0:8000
    ports:
      - "8000:8000"
    depends_on:
      - db
    environment:
      DATABASE_URL: postgresql://postgres.euvftjvhuieaiwgjdvyp:StudyProjectApp.@aws-1-eu-west-1.pooler.supabase.com:5432/postgres
      SECRET_KEY: dev_secret_key
      DEBUG: "True"
      CORS_ALLOWED_ORIGINS: http://localhost:3000
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:8000/api
      OPENROUTER_API_KEY: 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
      NEXT_PUBLIC_APP_URL: http://localhost:3000
      # For client side access, user needs access to backend from browser
      # Since we are not setting up nginx/proxy, browser access to backend relies on localhost:8000
      # But inside container, frontend server needs to talk to backend container?
      # Actually frontend server (for SSR) needs to talk to http://backend:8000/api
      # But client browser needs to talk to http://localhost:8000/api
      # Next.js usually proxies or uses distinct URLs.
      # Setting NEXT_PUBLIC_API_URL affects client bundle.
      # If running locally, localhost:8000 is fine.
      # If running in docker, client browser still hits localhost:8000 mapped port.

volumes:
  postgres_data:
